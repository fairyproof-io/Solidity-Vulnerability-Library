# 重放攻击

**漏洞名称：** 重放攻击  (Replay Attack)

**风险等级：** 致命 

**漏洞描述：**

重放攻击名称来源于传统网络安中的重放攻击（也叫重播攻击，回放攻击等）。是指攻击者发送一个已经被某合约处理过的请求（消息），然后合约又会重新处理该请求，从而形成重放漏洞，攻击主要用于智能合约中验证消息签名的场景。


**示例代码语言：** Solidity

**漏洞示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract ReplayDemo {
    address owner = msg.sender;

    constructor() payable {}

    function claimPayment(uint256 amount,  bytes memory signature) public {
        // A replay vulnerability can be formed here
        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, this)));
        require(recoverSigner(message, signature) == owner);
        payable(msg.sender).transfer(amount);
    }

    /// signature methods.
    function splitSignature(bytes memory sig)
        internal
        pure
        returns (uint8 v, bytes32 r, bytes32 s)
    {
        require(sig.length == 65);

        assembly {
            // first 32 bytes, after the length prefix.
            r := mload(add(sig, 32))
            // second 32 bytes.
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes).
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes memory sig)
        internal
        pure
        returns (address)
    {
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    /// builds a prefixed hash to mimic the behavior of eth_sign.
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}
```



**示例代码简介：**

在上面的代码中，管理员会对用户提币的数量进行签名，用户可以拿这个签名自主提币。然而由于签名仅验证了用户地址，提币数量和合约地址，使得用户可以拿相同的签名多次提币。



**单元测试代码：**

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ReplayDemo Test", function () {
    let instance;
    let owner,user1,user2,users;

    beforeEach( async function() {
        let ReplayDemo = await ethers.getContractFactory("ReplayDemo");
        instance = await ReplayDemo.deploy({
            value:ethers.utils.parseEther("2.0")
        });
        [owner,user1,user2,...users] = await ethers.getSigners();
    });
    
    describe('attack test', () => { 
        it("attack test", async () => {
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(ethers.utils.parseEther("2.0"));
            let message = ethers.utils.solidityKeccak256(
                ["address","uint256","address"],
                [user1.address,ethers.utils.parseEther("1.0"),instance.address]
            );
            let signature = owner.signMessage(ethers.utils.arrayify(message))
            await instance.connect(user1).claimPayment(ethers.utils.parseEther("1.0"),signature);
            await instance.connect(user1).claimPayment(ethers.utils.parseEther("1.0"),signature);
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(0);
        });
    })
});
```



在上面的单元测试代码中，使用相同的签名提取了两次。



**真实案例：**





**相关建议：**

1. 在进行类似的签名验证时，需要添加一些变量来区别不同的消息。例如添加用户的nonce并且记录其nonce使用过程。更安全的还包括不同链的chainId及合约地址。可以参考Solidity的官方示例合约：https://docs.soliditylang.org/en/v0.8.7/solidity-by-example.html#the-full-contract。