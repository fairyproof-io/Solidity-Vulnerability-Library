[back](../../README.md)
# Replay Attack

**name:** Replay Attack

**Severity:** Critical

**Description:** 

A replay attack (also known as a repeat attack or playback attack) refers to an attack in which an attacker repeatedly sends a request which has been processed by smart contracts. In this case the smart contracts process the request repeatedly. This attack happens quite often in scenarios in which signatures are verified. 


**Language:** Solidity

**Code Sample:**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract ReplayDemo {
    address owner = msg.sender;

    constructor() payable {}

    function claimPayment(uint256 amount,  bytes memory signature) public {
        // A replay vulnerability can be formed here
        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, this)));
        require(recoverSigner(message, signature) == owner);
        payable(msg.sender).transfer(amount);
    }

    /// signature methods.
    function splitSignature(bytes memory sig)
        internal
        pure
        returns (uint8 v, bytes32 r, bytes32 s)
    {
        require(sig.length == 65);

        assembly {
            // first 32 bytes, after the length prefix.
            r := mload(add(sig, 32))
            // second 32 bytes.
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes).
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes memory sig)
        internal
        pure
        returns (address)
    {
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    /// builds a prefixed hash to mimic the behavior of eth_sign.
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}
```



**Description of Code Sample:**

In the above code, the admin signs a withdrawal transaction and the user can use this signature to proceed with the withdrawal. However the signature only verifies the user's address, withdrawal quantity and contract address but doesn't verify the withdrawal's validity, the user can use this signature to withdraw cryptos repeatedly.




**Unit Test Code:**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ReplayDemo Test", function () {
    let instance;
    let owner,user1,user2,users;

    beforeEach( async function() {
        let ReplayDemo = await ethers.getContractFactory("ReplayDemo");
        instance = await ReplayDemo.deploy({
            value:ethers.utils.parseEther("2.0")
        });
        [owner,user1,user2,...users] = await ethers.getSigners();
    });
    
    describe('attack test', () => { 
        it("attack test", async () => {
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(ethers.utils.parseEther("2.0"));
            let message = ethers.utils.solidityKeccak256(
                ["address","uint256","address"],
                [user1.address,ethers.utils.parseEther("1.0"),instance.address]
            );
            let signature = owner.signMessage(ethers.utils.arrayify(message))
            await instance.connect(user1).claimPayment(ethers.utils.parseEther("1.0"),signature);
            await instance.connect(user1).claimPayment(ethers.utils.parseEther("1.0"),signature);
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(0);
        });
    })
});
```


In the above unit test code, the user uses the signature to withdraw cryptos twice.




**Real Case:**

OPTMISM token was transferred to the wrong chain and was finally replayed and taken away.



**Recommendations:**

1. 在进行类似的签名验证时，需要添加一些变量来区别不同的消息。例如添加用户的nonce并且记录其nonce使用过程。更安全的还包括不同链的chainId及合约地址。可以参考Solidity的官方示例合约：https://docs.soliditylang.org/en/v0.8.7/solidity-by-example.html#the-full-contract。