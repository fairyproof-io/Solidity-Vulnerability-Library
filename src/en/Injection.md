[back](../../README.md)
# Injection Attack

**name:** Injection Attack

**Severity:** Critical

**Description:** 

On Ethereum, calls between smart contracts can eventually be traced to invoking `call`, `delegatecall` or `staticcall`. In general such a call is implemented as a call from `a smart contract + a function defined in the contract`. However Solidity also allows a low-level function call which is  `<address>.call(payload)`. 


When an implementer uses the low level function call, the `address` and `payload` should be defined by the implementer and cannot be input by users. However inexperienced implementers may allow users to input one or both of them. In this case if a user maliciously inputs a payload or an address, unexpected risks will be introduced.

Here is a code sample.



**Language:** Solidity

**Code Sample:**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {
        _mint(msg.sender, initialSupply);
    }
}

contract InjectionDemo {
    function swap(address target, bytes calldata payload) external {
        (bool success,) = target.call(payload);
        require(success, "failed");
        // other operation
    }
}
```



**Description of Code Sample:**

In the above code, `InjectionDemo` acts as a router, its swap function allows a user to call functions from multiple third-party Dapps' contracts to do transactions such as token swap. But before these transactions can proceed, the user needs to approve these transactions. 

For instance, if user A arppoves `InjectionDemo` to spend his/her token AAA, user B can exploit this permission to transfer user A's token AAA. User B can do it this way: composing preferred transaction data, setting "address" to token AAA's contract address, setting `payload` to the composed transaction data and then calling the swap function to take away user A's token AAA.   



**Unit Test Code:**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("InjectionDemo Test", function () {
    let instance;
    let erc20;
    let owner,user1;

    beforeEach( async function() {
        let InjectionDemo = await ethers.getContractFactory("InjectionDemo");
        instance = await InjectionDemo.deploy();
        
        let MockERC20 = await ethers.getContractFactory("MockERC20");
        erc20 = await MockERC20.deploy("AAA","AAA",5000);
         
        [owner,user1,] = await ethers.getSigners();
    });
    
    describe('Injection attack test', () => { 
        it("Exploiter can steal user's token while user approve the InjectionDemo contract", async () => {
            // check balance
            expect(await erc20.balanceOf(user1.address)).to.be.equal(0);
            expect(await erc20.balanceOf(owner.address)).to.be.equal(5000);
            // approve 
            await erc20.approve(instance.address,1000);
            // user1 attack
            let allow = await erc20.allowance(owner.address,instance.address);
            expect(allow).to.be.equal(1000);
            let payload = erc20.interface.encodeFunctionData("transferFrom",[owner.address,user1.address,1000]);
            await instance.connect(user1).swap(erc20.address,payload);
            // check balance again
            expect(await erc20.balanceOf(user1.address)).to.be.equal(1000);
            expect(await erc20.balanceOf(owner.address)).to.be.equal(4000);
        });
    });
});
```

By executing the above test code, User 1 will exploit all the tokens that are approved InjectionDemo to spend.



**Real Case:**

Some popular cross-chain bridges suffered from injection attacks in which the attackers composed preferred payload data to exploit users' crypto assets.



**Recommendations:**

1. Don't use `call`, `delegatecall` or `staticcall` unless you are sure of what you are doing and it has to be done this way.
2. When you have to use a low-level function call, you need to carefully check the `address` and the `payload` data, make sure users can input at most one of the two and in no case should users input both of them. 
3. When either `address` or `payload` has to be input by users, the implementation must have restrictions on the user input and when necessary only specific addresses or function calls are allowed. 
4. When a low-level function call in which either `address` or `payload` has to be input by users is invoked, the implementation must check the statuses before and after the call.





