[back](../../README.md)
# Verification of tx.origin 

**name:** Verification of tx.origin 

**Severity:** Critical

**Description:** 

On Ethereum, a transaction can consist of multiple message calls. Each message call is an interaction between two addresses which can be either smart contract addresses or external account addresses.

In Solidity, a message call is initiated by a msg.sender which literally means a `message` is called by a `sender`.

On Ethereum, a transaction is initiated by `tx.origin`. Here `tx` means `transaction`.

Since a smart contract cannot autonomously run, it has to be triggered by a third-party. So a transaction must be triggered by an external account address from which a user initiates the transaction.

A transaction has one but only one `tx.origin` i.e. a transaction can be only initiated by one address. 

When we need to verify access control, in most scenarios we use `msg.sender` and in very limited scenarios we use `tx.origin`. For instance if we need to check whether or not an address is an external address or in some scenarios it is inappropriate to use "msg.sender", we use `tx.origin`. 

Consider a smart contract in which "msg.sender" should be used but `tx.origin` is used instead to verify access control, then when a user is misled to call a malicious contract, the malicious contract could pass the verification of access control.  

For instance:

1. Use `msg.sender` to verify that the caller should be user A.

2. User A calls contract B where `msg.sender` is required to be user A and the verification succeeds.

3. User A is misled to call a malicious contract C and C subsequently calls contract B. Since contract B requires `msg.sender` to be user A but now `msg.sender` is C, so the verification fails. 

4. Use `tx.origin` to verify that the caller should be user A.

5. User A calls contract B where `tx.origin` is required to be user A and the verification succeeds.

6. User A is misled to call a malicious contract C and C subsequently calls contract B. Contract B requires `tx.origin` to be user A and now `tx.origin` is STILL user A, so the verification STILL succeeds. The malicious contract C is authorized and unexpected risks are introduced!

Let's review a code sample.




**Language:** Solidity

**Code Sample:**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract B {
    uint public x;
    uint public y;

    address public owner;

    constructor(address _owner) {
        require(_owner != address(0), "zero address");
        owner = _owner;
    }

    function changeX(uint _x) external {
        require(msg.sender == owner, "not owner");
        x = _x;
    }

    function changeY(uint _y) external {
        require(tx.origin == owner,"not origin");
        y = _y;
    }
}

contract C {
    B public b;

    constructor(address _b) {
        require(_b != address(0));
        b = B(_b);
        b.x();
    }
    
    function attackX() external {
        b.changeX(789);
    }

    function attackY() external {
        b.changeY(789);
    }
}
```




**Description of Code Sample:**

In the above code, changeX uses "msg.sender" to verify permissions but ChangeY uses `tx.origin` to verify permissions. If an attacker deploys a malicious contract C, misleads user A to call the attackY function defined in contract C, he/she will be successfully modify the value of Y without permissions. 

However if the the malicious contract C calls changeX it will not pass the verification.



**Unit Test Code:**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("tx.origin Test", function () {
    let instance;
    let attack;
    let owner,user1;

    beforeEach( async function() {
        [owner,user1,] = await ethers.getSigners();

        let B = await ethers.getContractFactory("B");
        instance = await B.deploy(user1.address);
        
        let C = await ethers.getContractFactory("C");
        attack = await C.deploy(instance.address);
         
        
    });
    
    describe('tx.origin attack test', () => {
        it("user1 call changeX of B should be successful", async () => {
            await instance.connect(user1).changeX(6);
            expect(await instance.x()).to.be.equal(6);
        });

        it("user1 call changeY of B should be successful", async () => {
            await instance.connect(user1).changeY(8);
            expect(await instance.y()).to.be.equal(8);
        });

        it("user1 call attackY of C should be successfult", async () => {
            await attack.connect(user1).attackY();
            expect(await instance.y()).to.be.equal(789);
        });

        it("user1 call attackX of C should be failed", async () => {
            await expect(attack.connect(user1).attackX()).to.be.revertedWith("not owner");
            expect(await instance.y()).to.be.equal(0);
        });        
    });
});
```

In the above test code, if contract C calls the changeX function defined in contract B, the verification for `msg.sender` will fail, the transaction will be reverted and a `not owner` message will be sent out.

If contract C calls the changeY function, the verification for `tx.origin` will succeed and the value of Y can be modified thus introducing unexpected risks.



**Real Case:**

To be added




**Recommendations:**

1. Unless really needed (for instance requiring an address to be an external account address rather than a smart contract address), it is suggested to use `msg.sender` to verify permissions. If `tx.origin` should be used, consult with professionals and experts for advice.

