[后退](../../README_CN.md)
# EOA调用陷阱 

**风险名称：** EOA调用陷阱 (EOA Call Trap)

**风险等级：** 高

**风险描述：** 

在讲这个陷阱前让我们从最常见的ERC20代币及USDT讲起。

在Solidity中，当我们调用某个外部合约时，通常采用合约实例 + 函数名 + 输入参数的形式，例如我们调用一个ERC20合约的转账号函数，一般为`IERC20(addr).transfer(to,amount)`。我们查询ERC20标准可以得知，`transfer`会返回一个布尔类型的结果，于是我们可以进一步验证这个返回结果，例如如下代码示例：

```javascript
bool flag = IERC20(addr).transfer(to,amount);
require(flag,"transfer failed");
```

然而，现实中的情况是，部分非常常用的代币并没有采用ERC20标准，或者说不是标准的ERC20代币，例如USDT。USDT的代币合约的`transfer`函数并没有返回值，因此上面的示例代码适用在USDT时会失败。那么怎样解决呢？

方法1：专门定义一个USDT的接口，需要将标准ERC20接口中将`transfer`和`transferFrom`函数的返回值移除掉以适用USDT。
方法2：使用一个底层调用来直接调用相关地址的函数，例如`SafeERC20`库中的`safeTransfer`函数。

方法1的缺点在于无法统一适用USDT及标准ERC20代币，方法2可以，因此我们平常使用的最多的为方法2，但是该方法因为是底层调用，绕过了部分安全检查，因此存在一个重大陷阱，我们先看一个早期版本的`_safeTransfer`的代码定义(UniswapV2使用的）：

```javascript
bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));

function _safeTransfer(address token, address to, uint value) private {
    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
    require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
}
```

从上面的代码中我们可以看到，首先底层调用必须成功，其次，如果有返回值，那么返回值必须为`true`。这样如果标准ERC20有返回值，那么验证返回值为`true`，如果USDT这类代币没有返回值，只判断调用成功就行了。

然而在EVM中有一个特性，如果`call`调用一个不存在代码的地址，是直接返回调用成功的，这是什么意思呢？假如我们调用一个外部地址（以最常见的零地址）`_safeTransfer`，它也是可以调用成功并且无返回值，因此可以通过上面的验证。

当我们不小心将`token`的地址输入为一个错误地址或者重置为零地址时，`_safeTransfer`便会执行通过，然而用户实际并未转移代币，此时就会存在相应的安全隐患。不仅是转移代币，其它合约函数调用也是相同的。

其实上面的陷阱对任意外部地址（EOA）都是有效的，所以这里把它暂且称之为EOA调用陷阱。

然而这里并不是说UniswapV2中这样使用是有风险的，因为它pair中的两个代币地址是非常确认的两个ERC20兼容地址，并且不会变，所以不会出现EOA的情况。

那怎么 解决它呢？

方法很简单，在进行底层调用之前先判断该地址是否为合约地址。最新的`openzeppelin`包中的`SafeERC20`库中已经包含了该项验证，具体的代码片断为：

```javascript
/**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
function functionCall(address target, bytes memory data) internal returns (bytes memory) {
    return functionCall(target, data, "Address: low-level call failed");
}
```

上面的注释很清楚，使用普通的`call`并不安全，因此使用`functionCall`进行替代。而该函数内部进行了目标地址是否为合约的验证，这里源码不再列出了。




我们下面来看一个简单的验证示例：

**示例代码语言：** Solidity

**风险代码示例：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract CustomToken is ERC20 {
    constructor(string memory _name, string memory _symbol) ERC20(_name,_symbol) {
        _mint(msg.sender, 100000);
    }
}

contract ZeroAddressDemo {
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes("transferFrom(address,address,uint256)")));

    address public token1;
    address public token2;
    address public owner;

    constructor(address _token1,address _token2) {
        token1 = _token1;
        token2 = _token2;
        owner = msg.sender;
    }

    function getTokenBalance(address token) external view returns(uint) {
        return ERC20(token).balanceOf(address(this));
    }

    function resetToken2(address _token2) external {
        require(msg.sender == owner, "not owner");
        token2 = _token2;
    }

    function stakeToken1(uint amount) external {
        require(amount > 0, "amount == 0");
        _safeTransferFrom(token1,msg.sender,address(this),amount);
    }

    function stakeToken2(uint amount) external {
        require(amount > 0, "amount == 0");
        _safeTransferFrom(token2,msg.sender,address(this),amount);
        
    }

    function stakeToken2New(uint amount) external {
        require(amount > 0, "amount == 0");
        _safeTransferFromNew(token2,msg.sender,address(this),amount);
        
    }

    function _safeTransferFrom(address token, address from, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "TRANSFERFROM_FAILED");
    }

    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.
        return account.code.length > 0;
    }

    function _safeTransferFromNew(address token, address from, address to, uint value) private {
        require(isContract(token), "must be contract");
        _safeTransferFrom(token,from,to,value);
    }
}
```



**示例代码简介：**

在上面的代码中，`_safeTransferFrom`使用原始的`call`调用，存在外部地址陷阱，当我们通过`resetToken2`函数将`token2`重置为一个外部EOA地址（例如零地址）时，用户执行`stakeToken2`函数仍然会成功。

`_safeTransferFromNew`增加了一个`isContract`验证，因此当`token2`重置为一个外部EOA地址时，检查通不过，交易便不会执行。

虽然`isContract` 在合约构造器中无效，但是我们这里的`token2`地址是手动设置的，设置为一个未部署的合约地址然后在构造器中进行`stakeToken2New`调用几乎是不存在的。

我们来看单元测试：

**单元测试代码：**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ZeroAddressDemo Test", function () {
    let token1,token2;
    let instance;
    let owner,users;

    beforeEach(async function() {
        CustomToken = await ethers.getContractFactory("CustomToken");
        token1 = await CustomToken.deploy("Token1","T1");
        token2 = await CustomToken.deploy("Token2","T2");
        let ZeroAddressDemo = await ethers.getContractFactory("ZeroAddressDemo");
        instance = await ZeroAddressDemo.deploy(token1.address,token2.address);
        [owner,...users] = await ethers.getSigners();
    });
    
    describe("stake test while token1 and token2 are all valid", () => {
        it("stake token1 test", async () => {
            expect(await instance.getTokenBalance(token1.address)).to.be.equal(0);
            await token1.approve(instance.address,100);
            await instance.stakeToken1(100);
            expect(await instance.getTokenBalance(token1.address)).to.be.equal(100);
        });

        it("stake token2 test", async () => {
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(0);
            await token2.approve(instance.address,1000);
            await instance.stakeToken2(1000);
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(1000);
        });

        it("stake token2 new test", async () => {
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(0);
            await token2.approve(instance.address,1000);
            await instance.stakeToken2New(1000);
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(1000);
        });
    });

    describe("stakeToken2 test while token2 is reset to an invalid address", () => {
        it("stake token2 while token2 is reset to an invalid contract address", async () => {
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(0);
            await token2.approve(instance.address,100);
            await instance.resetToken2(instance.address);
            await expect(instance.stakeToken2(100)).to.be.revertedWith("TRANSFERFROM_FAILED");
        });

        it("stake token2 while token2 is reset to an arbitrary EOA address", async () => {
            await token2.approve(instance.address,100);
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(0);
            await instance.resetToken2(ethers.constants.AddressZero);
            await instance.stakeToken2(100);
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(0);
            let addr = "0x" + "0".repeat(39) + "1";
            await instance.resetToken2(addr);
            await instance.stakeToken2(100);
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(0);
        });
    });

    describe("stakeToken2New test while token2 is reset to an invalid address", () => {
        it("stake token2 while token2 is reset to an EOA address", async () => {
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(0);
            await token2.approve(instance.address,100);
            await instance.resetToken2(ethers.constants.AddressZero);
            await expect(instance.stakeToken2New(100)).to.be.revertedWith("must be contract");
            let addr = "0x" + "0".repeat(39) + "1";
            await instance.resetToken2(addr);
            await expect(instance.stakeToken2New(100)).to.be.revertedWith("must be contract");
        });

        it("stake token2 while token2 is reset to an invalid contract address", async () => {
            expect(await instance.getTokenBalance(token2.address)).to.be.equal(0);
            await token2.approve(instance.address,100);
            await instance.resetToken2(instance.address);
            await expect(instance.stakeToken2(100)).to.be.revertedWith("TRANSFERFROM_FAILED");
            await expect(instance.stakeToken2New(100)).to.be.revertedWith("TRANSFERFROM_FAILED");
        });
    });
});
```



从上面的单元测试代码我们可以看到，如果使用底层的`call`调用一个外部EOA地址，那么不管调用的`payload`是什么，都是可以调用成功（调用结果返回true）并且无返回值的。如果`call`调用一个合约地址，而该合约又无对应的函数，则`call`调用结果会返回一个`false`。

而我们添加了`isContract`验证后，再调用EOA地址，验证就会失败重置，后面来`call`调用根本不会执行。



**真实案例:**

Qubit protocol 在误操作后将WETH的地址设置为了零地址，此时用户调用的质押函数中有如下代码：

```javascript
tokenAddress.safeTransferFrom(depositer, address(this), amount);
```

因为tokenAddress为零地址，所以根据上面我们的示例，不管用户有没有WETH或者有多少，上面执行均可以通过。

此漏洞最终造成了8000万 美元的损失。



**相关建议:**

1. 使用最新版本的`openzeppelin`包中的`SafeERC20`库来进行替换自定义的操作。

2. 更改参数时注意增加非零地址验证。

3. 使用底层调用时手动添加`isContract`验证。

   