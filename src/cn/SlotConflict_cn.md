[后退](../../README_CN.md)
# 插槽冲突 

**风险名称：** 插槽冲突 (Slot Conflict)

**风险等级：** 高

**风险描述：** 

在Solidity中，当函数操作合约的状态变量时，在源码中使用的是变量名，但在实际操作中是根据变量的插槽索引操作的。

一般类型的变量它的插槽索引根据它定义的顺序从零开始往下排，特殊类型的变量的插槽索由相应的公式计算，例如数组中每个元素的插槽，

mapping中每个值的插槽等。

涉及到代理/实现这种利用委托调用来实现可升级模式的合约来讲，实现合约操作的是插槽索引，但是它对应的存储却又是代理合约的。

如果同一个插槽在代理合约和实现合约中对应的是不同的变量，此时便会产生插槽冲突，实现合约会修改其它状态变量，从而破坏合约的功能。

这样的风险出现的频率不高，主要用于自定义的代理和实现合约时，我们可以看以下示例:


**示例代码语言：** Solidity

**风险示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract Impl {
    address public minter;

    function getMinter() external view returns(address) {
        return minter;
    }

    function setMinter(address _newMinter) external {
        minter = _newMinter;
    }
}

contract Proxy {
    address public impl;
    address public minter;

    constructor(address _implement) {
        impl = _implement;
    }

    function setImplement(address _implement) public {
        impl = _implement;
    }

    function getImplement() public view returns(address) {
        return impl;
    }

    /**
     * @dev Delegates execution to an implementation contract.
     * It returns to the external caller whatever the implementation returns
     * or forwards reverts.
     */
    fallback() external {
        // delegate all other functions to current implementation
        (bool success, ) = impl.delegatecall(msg.data);

        assembly {
              let free_mem_ptr := mload(0x40)
              returndatacopy(free_mem_ptr, 0, returndatasize())

              switch success
              case 0 { revert(free_mem_ptr, returndatasize()) }
              default { return(free_mem_ptr, returndatasize()) }
        }
    }
}
```



**示例代码简介：**

在上面的代码中，`Proxy`合约和`Impl`合约都有相同的状态变量`minter`，这样相关的逻辑才可以在两个合约都运行。

不同的是，在`Proxy`合约中，按照定义顺序，`impl`的值也就是实现合约地址为插槽0，`minter`地址的值为插槽1。

而在`Impl`合约中，`minter`地址的值为插槽0，这样`minter`的值在两个合约中的插槽不一致，形成了冲突。

当`Proxy`通过委托调用`Impl`合约的`getMinter`或者`setMinter`函数来读写相应的`minter`变量时，它实际操作的是`Proxy`合约的`impl`变量。

我们看下单元测试代码来加深理解。



**单元测试代码：**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("SlotConflict Test", function () {
    let proxy;
    let Impl,impl;
    const BLACK_HOLE_ADDRESS = ethers.utils.getAddress("0x" + "0".repeat(36) + "dead");

    beforeEach(async function() {
        Impl = await ethers.getContractFactory("Impl");
        impl = await Impl.deploy();
        let Proxy = await ethers.getContractFactory("Proxy");
        proxy = await Proxy.deploy(impl.address);
    });
    
    describe('minter get/set test', () => {

        it("The minter function should return zero address", async () => {
            expect(await proxy.minter()).to.be.equal(ethers.constants.AddressZero);
        });

        it("The getMinter function should return the address of impl", async () => {
            let instance = await Impl.attach(proxy.address);
            // This returns the address of impl, not the minter.
            expect(await instance.getMinter()).to.be.equal(impl.address);
        });

        it("The setMinter function change the address of impl", async () => {
            // initial state
            expect(await proxy.impl()).to.be.equal(impl.address);

            // setMinter
            let instance = await Impl.attach(proxy.address);
            await instance.setMinter(BLACK_HOLE_ADDRESS);

            // check state
            expect(await proxy.impl()).to.be.equal(BLACK_HOLE_ADDRESS);
            expect(await proxy.minter()).to.be.equal(ethers.constants.AddressZero);

            // getMinter should be reverted because the address of implement is changed.
            await expect(instance.getMinter()).to.be.revertedWith("call revert exception");
        });
    });
});
```

通过上面的单元测试代码，我们可以看到，刚开始我们读取`Proxy`合约的`impl`地址为正确的地址，其`minter`地址为零地址，而我们通过委托调用来调用`Proxy`合约的`getMinter`函数时，返回的是`impl`的地址，可见这个时候代理合约和实现合约的状态已经不一致了。

当我们调用`setMinter`函数来将`Proxy`合约的`minter`设置一个新值时，我们实际操作的是`impl`变量，最后测试结果也印证了：

1. `impl`地址变成我们单元测试中的`BLACK_HOLE_ADDRESS`了。
2. `minter`地址仍然为零地址。
3、`getMinter`函数无法调用了，因为新的`impl`地址`BLACK_HOLE_ADDRESS`并没有包含相关的代码。


**真实案例:**

待添加



**相关建议:**

1. 在采用代理/实现这种设计模式时，代理合约定义越少的状态变量越好，并且不要和实现合约重复。

2. 万一代理/实现合约有相同的状态变量，一定要保证状态变量的位置一致，可以参考`Compound`中的相关实现。

3. 推荐使用`OpenZeppelin`的相关模板库来设计代理/实现模式。

4. 如果实现合约欲替换升级，新增加的状态变量一定不能放在已有的状态变量之前，旧的状态变量的顺序也不能打乱。

   