[后退](../../README_CN.md)
# 变量隐藏 

**风险名称：** 变量隐藏 (Shadow Variable)

**风险等级：** 高

**风险描述：** 

在Solidity中，每个变量有自各不同的作用域，例如状态变量就是从定义开始到合约结束。

然而，如果我们一不小心又在某个函数内部定义了一个相同名称的局部变量，这时会变造成变量隐藏（Shadow）,也就是作用域较小的变量隐藏了作用域更大的变量。

变量隐藏在其它编程语言中也会出现，在Solidity中，出现变量隐藏一般是由于笔误原因，而不是真的想定义一个同名变量。

由于变量隐藏是合法的，因此编译器会给出编译警告，而不是错误，并且编译可以通过。

通常，部分开发者并不会注意编译警告的内容，所以很可能造成合约漏洞。

我们下面来看一个简单的例子:

**示例代码语言：** Solidity

**风险示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract ShadowDemo {

    uint public amount;
    uint public price;

    function updateOnce(uint rand) external returns(uint) {
        require(rand <100 && price == 0); // only once
        if(rand <= 30) {
            // skip
            price = 1e16;
            amount = 1000;
            return amount;
        } else if (rand <= 50) {
            price = 1e15;
            amount = 10000;
            return amount;
        } else if (rand <= 90) {
            price = 1e14;
            amount = 1000000;
            return amount;
        } else {
            price = 1e13;
            uint amount = 10000000;
            return amount;
        }
    }
}
```



**示例代码简介：**

在上面的代码中，`updateOnce`函数用来设置两个状态变量的初始值，然而在最后一个条件分支`else`时，由于笔误，将

`amount = 10000000` 写成了 `uint amount = 10000000;`。那么在最后一个`else`语句里，本地变量`amount`便`shadow`了状态变量`amount`。

当我们编译该合约时，提示如下:

```bash
Warning: This declaration shadows an existing declaration.
  --> contracts/ShadowDemo.sol:26:13:
   |
26 |             uint amount = 10000000;
   |             ^^^^^^^^^^^
Note: The shadowed declaration is here:
 --> contracts/ShadowDemo.sol:6:5:
  |
6 |     uint public amount;
  |     ^^^^^^^^^^^^^^^^^^
```

如果我们忽视了这个编译警告，那么调用`updateOnce`函数时，如果参数值 `rand > 90` 那么状态变量`amount`的值便得不到初始化，仍然为默认值零。

这时如果外部合约调用我们的`amount`接口进行相关计算，便会导致预期外的结果。

我们来看单元测试：

**单元测试代码：**

```javascript
// SPDX-License-Identifier: GPL-3.0
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ShadowDemo Test", function () {
    let instance;

    beforeEach( async function() {
        let ShadowDemo = await ethers.getContractFactory("ShadowDemo");
        instance = await ShadowDemo.deploy();
    });
    
    describe('update test', () => { 
        it("Rand less than 30 and amount equals 1000 test", async () => {
            await instance.updateOnce(25);
            expect(await instance.amount()).to.be.equal(1000);
        });

        it("Rand less than 50 and amount equals 10000 test", async () => {
            await instance.updateOnce(45);
            expect(await instance.amount()).to.be.equal(10000);
        });

        it("Rand less than 90 and amount equals 100000 test", async () => {
            await instance.updateOnce(75);
            expect(await instance.amount()).to.be.equal(1000000);
        });

        // failed
        it("Rand less than 100 and amount equals 1000000 test", async () => {
            await instance.updateOnce(95);
            expect(await instance.amount()).to.be.equal(1000000);
        });

        it("Rand greater than 90  and amount equals zero test", async () => {
            await instance.updateOnce(95);
            expect(await instance.amount()).to.be.equal(0);
        });
    });
});
```

运行上面的单元测试代码，会得到如下结果：
```bash
RollBackDemo Test
    update test
      ✔ Rand less than 30 and amount equals 1000 test (40ms)
      ✔ Rand less than 50 and amount equals 10000 test
      ✔ Rand less than 90 and amount equals 100000 test
      1) Rand less than 100 and amount equals 1000000 test
      ✔ Rand less than 100  and amount equals zero test


  4 passing (1s)
  1 failing

  1) RollBackDemo Test
       update test
         Rand greater than 90 and amount equals 1000000 test:
     AssertionError: Expected "0" to be equal 1000000
      at Context.<anonymous> (test/ShadowDemo-test.js:32:51)
```

从上面的结果我们看到，当`updateOnce`的参数为95时，我们只是将一个临时变量进行了赋值，并没有初始化状态变量`amount`.


**真实案例:**

待添加



**相关建议:**

1. 如果不是确定自己在做什么，不要重复定义相同名称的变量。

2. 要将每个编译警告当成编译错误来对待，尽力解决每一个编译警告。

   