[后退](../../README_CN.md)
# Delete 陷阱

**风险名称：** Delete 陷阱 (Delete Trap)

**风险等级：** 中

**风险描述：** 

在Solidity中，存在`delete`操作，可以删除一个变量。在这里，删除变量的意思是指将该变量恢复到默认值。

Solidity中，值类型的默认值很简单，例如整数统一为0，布尔型统一为false，合约或者地址类型统一为零地址。

bytes32类型为"0x"， 字符串类型为""。

涉及到数组时，固定大小数组为将每个元素设置为默认值；动态大小的数组是将该数组长度重置为0。

然而需要注意的是，当涉及到mapping时，并没有删除整个mapping的操作，它只删除它的某个`key`对应的值。

当单独应用`mapping`时，我们一般不会进行删除操作，因为此时无法通过编译，例如如下代码无法通过编译：

```solidity
mapping(uint => uint) public scores;
scores[22] =  200;
...
delete scores;  // 无法通过编译
delete scores[22]  // 重置对应的值为0
```

因此，我们会注意到此时需要删除具体的某个`key`对应的值，例如`delete scores[22]`，那么在该`mapping`中，`key`为`22`对应的值就为`0`（整数的默认值为0）。

然而，当我们在结构体中包含`mapping`时，我们可以直接删除结构体对应的变量，此时并不会给出不能编译提示。但该结构内的`mapping`是并没有删除的，其内容依然没有存在。当有外部合约或者接口读取该`mapping`的内容时，便会返回旧值。

**示例代码语言：** Solidity

**风险示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

struct A {
    uint x;
    uint y;
    mapping(address => uint) scores;
    uint[] lists;
}

contract DeleteDemo {
    bool public initialized;
    uint public value;
    address public owner;
    bytes32 public transaction;
    bytes public name;
    string public description;
    uint[3] public fixedArray;
    mapping(bytes32 => A) public infos;


    function init(
        bytes32 _hash,
        bytes calldata _name,
        string calldata _description
    ) external {
        require(!initialized);
        initialized = true;
        value = 10;
        owner = msg.sender;
        transaction = _hash;
        name = _name;
        description = _description;
        fixedArray = [1,2,3];
        A storage a = infos[_hash];
        a.x = 5;
        a.y = 6;
        a.lists.push(555);
        a.scores[msg.sender] = 666;
    }

    function getListLength(bytes32 key) external view returns(uint) {
        return infos[key].lists.length;
    }

    function getListItem(bytes32 key, uint index) external view returns(uint) {
        A storage a = infos[key];
        require(index < a.lists.length);
        return a.lists[index];
    }

    function getScore(bytes32 key, address user) external view returns(uint) {
        A storage a = infos[key];
        return a.scores[user];
    }

    function clear() external {
        require(msg.sender == owner);
        delete initialized;
        delete value;
        delete owner;
        delete infos[transaction];
        delete transaction;
        delete name;
        delete description; 
        delete fixedArray;
    }

    function clearScores(bytes32 key, address[] calldata users) external {
        require(infos[key].lists.length == 0);
        for(uint i=0;i<users.length;i++) {
            address user = users[i];
            delete infos[key].scores[user];
        }
    }
}
```



**示例代码简介：**

在上面的代码中，`clear`函数用来清除所有状态变量和`infos`中初始化过的值。然而由于上述陷阱的存在，我们不得不额外使用一个函数来清除结构`A`中对应的`scores`字段中的内容。



**单元测试代码：**

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("DeleteDemo Test", function () {
    let instance;
    let owner;

    beforeEach( async function() {
        let DeleteDemo = await ethers.getContractFactory("DeleteDemo");
        instance = await DeleteDemo.deploy();
         
        [owner,] = await ethers.getSigners();
    });
    
    describe('DeleteDemo  test', () => {
        const tx = ethers.utils.hashMessage("DeleteDemo test");
        it("Delete does not reset mapping", async () => {
            // check state
            expect(await instance.initialized()).to.be.false;
            expect(await instance.value()).to.be.equal(0);
            expect(await instance.owner()).to.be.equal(ethers.constants.AddressZero);
            expect(await instance.transaction()).to.be.equal(ethers.constants.HashZero);
            expect(await instance.name()).to.be.equal("0x");
            expect(await instance.description()).to.be.equal("");
            for(let i=0;i<3;i++) {
                expect(await instance.fixedArray(i)).to.be.equal(0);
            }
            // check infos
            expect((await instance.infos(tx)).x).to.be.equal(0);
            expect((await instance.infos(tx)).y).to.be.equal(0);
            expect(await instance.getListLength(tx)).to.be.equal(0);
            expect(await instance.getScore(tx,owner.address)).to.be.equal(0);

            // init
            await instance.init(
                tx,
                ethers.utils.formatBytes32String("DeleteDemo"),
                'DeleteDemo  test'
            );

            // check state again
            expect(await instance.initialized()).to.be.true;
            expect(await instance.value()).to.be.equal(10);
            expect(await instance.owner()).to.be.equal(owner.address);
            expect(await instance.transaction()).to.be.equal(tx);
            let name = await instance.name();
            name = ethers.utils.parseBytes32String(name);
            expect(name).to.be.equal("DeleteDemo");
            expect(await instance.description()).to.be.equal("DeleteDemo  test");

            for(let i=0;i<3;i++) {
                expect(await instance.fixedArray(i)).to.be.equal(i + 1);
            }
            // check infos
            expect((await instance.infos(tx)).x).to.be.equal(5);
            expect((await instance.infos(tx)).y).to.be.equal(6);
            expect(await instance.getListLength(tx)).to.be.equal(1);
            expect(await instance.getScore(tx,owner.address)).to.be.equal(666);

            // clear
            await instance.clear();

            // check state again
            expect(await instance.initialized()).to.be.false;
            expect(await instance.value()).to.be.equal(0);
            expect(await instance.owner()).to.be.equal(ethers.constants.AddressZero);
            expect(await instance.transaction()).to.be.equal(ethers.constants.HashZero);
            expect(await instance.name()).to.be.equal("0x");
            expect(await instance.description()).to.be.equal("");

            for(let i=0;i<3;i++) {
                expect(await instance.fixedArray(i)).to.be.equal(0);
            }

            // check infos 
            // Fields of value type in struct are reset to default values;
            expect((await instance.infos(tx)).x).to.be.equal(0);
            expect((await instance.infos(tx)).y).to.be.equal(0);

            // array reset to zero length
            expect(await instance.getListLength(tx)).to.be.equal(0);

            // Caution: mapping is not reset
            expect(await instance.getScore(tx,owner.address)).to.be.equal(666);

            // clear score
            await instance.clearScores(tx,[owner.address]);
            expect(await instance.getScore(tx,owner.address)).to.be.equal(0);
        });
    });
});
```

通过上面的单元测试代码，我们可以看到，`clear`操作可以清除绝大部分变量的值为默认值，但是结构体中的`mapping`数据不行，访问仍然返回的是值`666`。我们只有在调用`clearScores`函数手动清除结构体内的`mapping`对应的`key`后，该结构体对象的内容才算是彻底清除。



**真实案例:**

暂无



**相关建议:**

1. 当使用复杂数据结构时，特别涉及到`mapping`时，一定要弄明白`delete`操作的含义。

4. 咨询专业的安全审计公司进行合约代码审计。

   